11일차================================================
#String 클래스 - 메소드 기능을 이해하여 적절하게 활용
#상속
	-부모 클래스를 물려 받는 것
	-부모는 한 클래스만 가능
	-private으로 된 필드/메소드는 상속은 받으나 직접 접근할 수 없다.
	-상속은 왜 사용?
		-코드의 중복을 제거
		-다양성을 통해 효율적으로 작업하기위해서
	
-클래스 형변환
	-자식 클래스 객체 => 부모 클래스 객체 : 항상 가능, 자동
	-부모 클래스 객체 => 자식 클래스 객체 : 조건부 가능, 강제
	-업 캐스팅(자동) : 
		-자식 클래스의 객체를 부모 클래스의 객체에 저장
	-다운 캐스팅(강제) :
		-부모 클래스의 객체를 자식 클래스의 객체에 저장
		-조건부로 가능
			-업캐스팅된 부모 객체를 다운 캐스팅하는 경우 가능 
#매개변수의 다형성
	-같은 기능을 하는 메소드가 있는데 매개변수로 객체들 종류만 다른 경우
	 여러 객체들의 조상 클래스의 객체로 매개변수를 정한다
	 =>메소드 오버로딩 개수를 줄임
배운것 정리=======================================
#변수 
	-변수 선언방법
	-자료형
	-변수명 작성 규칙과 관례
	-자료형 변환
#연산자
	-연산자 종류 및 결과
	-단항 : ++,--,!
	-이항 : 대부분
	-삼항 : 조건선택연산자
	-증감 : ++,--
	-산술 : +,-,*,/,%
	-비교 : 크기 비교, 조건식
	-논리 : 참,거짓, 조건식
	-대입 : =
#조건식
	-조건문 사용
	-if문 => 조건식
	-switch문 => 변수 또는 식 => 정수,문자열,문자
#반복문
	-for문,while문
	-do while문 : 최소 1번 실행
#배열
	-배열 선언 방법
	-배열은 0번지부터 배열은 크기-1번지까지
	-번지를 잘못접근하면 예외발생
12일차=============================================
	1. 예제가 주어졌을 때 예제를 이해한다.
	2. 예제를 풀기 위해 사용해야하는 문법을 파악할 수 있다.
	3. 예제를 해결하기 위해 단계를 구분할 수 있다.(주석으로 나눌 수 있다)
	4. 예제를 풀기 위해 필요한 변수, 배열, 객체등을 선정할 수 있다.
	5. 부분적으로(3번에서 작성한 단계별) 코딩을 통해 해결 할 수 있다.
	6. 원하는 코딩을 작성할 수 있다.
	7. 작성한 코딩을 효율적으로 정리할 수 있다.
#추상 클래스(abstract,interface)
	//접근제한자 예약어 리턴타입 메소드명(매개변수);
	//추상 클래스를 상속받은 일반 클래스는 부모의 추상 메소드를 반드시 오버라이딩해야함
	//추상 클래스를 상속받은 추상 클래스는 부모의 추상 메소드를 반드시 오버라이딩해야 하는 건 아님
	-몸체없는 메소드를 포함한 클래스, 클래스 선언부에 abstract 키워드 사용
	-장점 : 일관된 인터페이스 제공
#interface : 공동 작업을 위한 인터페이스 제공
	-모든 인터페이스의 메소드는 public
	-자동으로 public static final이 붙음
#Object 클래스
	-모든 클래스의 조상 클래스
	-Object 클래스에 있는 메소드들을 오버라이딩하여 활용할 수 있다.
	-equals(Object obj)
		-Object의 equals는 주소를 비교
		-오버라이딩해서 사용
	-toString()
		-객체의 정보를 하나의 문자열로 변환 
		-오버라이딩해서 필드정보를 쉽게 확인할 수 있게함
13일차==============================================
구글에 lombok을 쓰면 겟터셋터를 @Data를 이용해 사용가능함
lombok은 구글에 검색해서 사용하기
 #변수
	-데이터를 저장하는 물리적인 공간
	-변수 선언방법
	자료형 변수명 = 초기값;
	-변수명 작성 규칙
	-자료형 변환(기본자료형)
		-자동
			-작은 데이터를 큰 데이터에 저장하는 경우
			-정수를 실수에 저장하는 경우
			-자동으로 변환
		-강제(명시적)
			-큰 데이터를 작은 데이터에 저장하는 경우, 손실이 발생할 수 있음
			-자동으로 가능하지만 필요에 의해 강제로 하는 경우가 있음(나누기)
			-값 또는 변수 앞에 (자료형)을 붙여서 형변환 함
 #연산자
  	-산술 : 정수/정수 =>정수 를 조심(데이터 손실이 일어날 수 있음)
  	-비교 연산자
  		-==를 =과 혼동하면 안됨
  		-참조변수는 ==를 이용할 때 조심. 참조변수의==는 값이 같은것을 물어보는게 아니라 같은 객체를 
  		 공유하는지 물어봄
  	-논리 연산자
  		-조건식이 복잡하면 논리연산자를 잘못 쓸 수 있음
  	-증감연산자
  	-조건선택연산자 : 마음의 여유가 있을때
  	-대입 연산자 : 오른쪽 값을 왼쪽에 저장.덮어쓰기
  #조건문
  	-~하면...한다
  	 ~:조건식, ...:실행문
  #반복문
  	-횟수 정하기
  	-무한루프,한번도 실행 안되는 경우 조심
  	-continue
  		-for문은 증감식, while , do while문은 조건식 이동
  	-break : 반복문을 빠져나옴
  #배열
  	-같은 자료형으로 된 데이터들을 모아 놓은 곳
  	-반복문을 사용하여 데이터들을 편리하게 관리하기 위해 사용
  	-배열 선언 방법
  		자료형[]배열명 =new 자료형[크기];
  		-할당된 배열 각 번지는 자료형에 맞는 초기값으로 초기화가 된다.
  		-시작번지는 0번지,마지막번지는 크기-1
  		-배열 arr에 i번지에 있는 값을 접근: arr[i]
  #클래스
  	-하나의 정보를 표현하기 위해 여러 변수들과 기능들을 모아 놓은 것
  	-필드, 메소드, 생성자
  	-필드 : 속성, 정보, 공통된 정보
  		-필드는 일반적으로 접근제한자가 private => getter/setter필요
  	-메소드 : 필요한 기능, 대부분 필드값을 변경되게 하는 기능
  		-메소드는 일반적으로 접근제한자가 public
  	-생성자 : 필드 초기화
  #접근제한자 
  	- private : 나
  	- default : 나 +같은패키지 내 클래스
  	- protected : 나 +같은패키지 내 클래스 +자식클래스
  	- public : 나 +같은패키지 내 클래스 +자식클래스 +외부클래스
  같은 이름의 클래스는 존재할 수 있다?없다?
	-같은 패키지내에서는 존재 할 수 없다
	-다른 패키지에서는 존재 할 수 있다
  public 클래스가 되기 위한 조건?
  	-클래스명과 파일명이 동일
  필드 초기화 순서
  	-클래스 필드 : static이 붙은 필드, 클래스가 메모리에 올라오면 필드들이 할당,객체들이 클래스 필드를 공유
  		1.필드의 기본값으로 초기화
  		2.명시적 초기화(선언과 동시에 초기화)
  		3.초기화 블록(static{}안에있는)
  	-인스턴스 필드 : static이 안붙은 필드,객체가 생성될 때 필드들이 할당,객체마다 인스턴스 필드를 가지고 있음
  		1.필드의 기본값으로 초기화
  		2.명시적 초기화(선언과 동시에 초기화)
  		3.초기화블록({}안에있는)
  		4.생성자
  클래스 필드/메소드
  	-클래스 메소드에서 사용 가능?O
  	-인스턴스 메소드에서 사용 가능?O
  인스턴스 필드/메소드
  	-클래스 메소드에서 사용 가능?X
  		-직접 사용은 불가능하지만 객체를 생성 후 사용하는 건 가능
  	-인스턴스 메소드에서 사용 가능?O 
  #상속
  	-부모클래스의 필드/메소드를 물려받아 자식클래스가 활용하는 것
  	-접근제한자가 private인 필드/메소드는 직접 접근해서 사용할 수 없다
  	@상속하는 이유
  		-코드의 중복을 제거
  		-다형성을 이용하여 메소드 중복을 제거
  	class 자식클래스명 extends 부모클래스명{}
  	@클래스에서 부모클래스는 1개
  	@인터페이스에서 부모 인터페이스는 여러개
  	
  	다형성 : 하나의 객체가 여러가지 타입을 가질수 있는것
  	매개변수의 다형성
  		-매개변수로 여러 객체들이 올 수 있다, 이때 매개변수로 오는 객체들이 동일한 
  		 조상 클래스의 자식클래스들인 경우, 매개변수를 조상클래스의 객체로 선언하면 여러 메소드를 만들
  		 필요가 없다.
  		-조건은 자식클래스가 부모클래스를 상속받아야함
  	객체의 다형성
  		Tv tv1,tv2,tv3;
  		컴퓨터 com1,com2,com3;
  		에어컨 에어컨1;
  		=>위 코드에서는 다양한 클래스의 객체들을 하나로 관리할 수 없다
  		전자제품[]pro;
  #클래스 변환
  	-자동
  		-자식객체 => 부모객체에 저장
  	-강제
  		-부모객체 => 자식객체에 저장(조건부)
  		-부모객체와 연결된 객체가 자식클래스 객체인 경우, 강제 클래스 변한이 가능
  		-부모객체와 연결된 객체가 부모클래스 객체인 경우, 강제 클래스 변환이 불가능
  	-instanceof :연산자, 클래스 변환이 가능한지 불가능한지 알려주는 연산자
  		-조건문과 같이 활용(결과값이 참,거짓으로 나오기 때문에)
  #인터페이스	
  	-추상메소드와 클래스 상수로만 이루어진 것
  	-기능들을 표준화, 기능 명세
  #추상메소드
  	-메소드 구현부가 없는 메소드
  	-기능을 사용하려면 메소드 오버라이딩을 통해 구현을 한 후, 호출
  #구현클래스 : 인터페이스를 구현한 클래스
  	-인터페이스에 있는 메소드들을 반드시 오버라이딩해야 한다
  	-구현클래스는 여러 인터페이스를 구현할 수 있다
  	@class A implements interfaceA,interfaceB{}
  	-구현클래스 A는 인터페이스 interfaceA와 interfaceB를 구현한 구현 클래스이다
  	@상속과 구현은 같이 할 수 있다
  	class Child extends Parent implements InterfaceA{}
  #String클래스
  	-indexOf(),equals(),length(),subString(), split()
  #Object클래스
  	-equals(),toString()
  #Wrapper클래스 : 기본자료형을 클래스로 만든것
  	-int => Integer
  	-boolean =>Boolean
  	-char =>Charater
  	-double =>Double
 #날짜==================
 Date date1 = new Date(); : 현재 시간 정보를 가져옴
 System.currentTimeMillis() : 현재 시스템 시간을 밀리세컨드로 환산
 14일차============================================
 #예외처리
 	-런타임익셉션 클래스 : 프로그래머의 부주의로 인한 오류인 경우가 많기 때문에 예외처리보다는 코드를 수정
 	-예외처리 방법
 	 1.Exception이 발생한 곳에서 직접 처리
 	 -try~catch문을 이용하여 예외처리
 	 2.Exception 처리를 호출한 메소드에게 위임
 	 -throw
 #컬렉션
 	-저장하는 크기의 제약이 없다.
 	-추가, 삭제, 정렬등의 기능처리가 간단하게 해결되어 자료구고적 알고리즘을 구현할 필요없음
 	-여러타입의 데이터를 저장할수있다
 	@List계열 : 순서 유지하고 저장, 중복저장 가능
 		-자료들을 순차적으로 나열한구조로 인덱스로 관리되며 중복해서 객체저장가능
 		ArrayList : 초기저장용량은 10으로 자동 설정,자동으로 늘어남
 		vector : ArryList와 동일하지만 동기화를 제공->성능이 가장 안좋음
 		LinkdList : 삭제와 수정이 빈번하게 일어나는곳에서 ArrayList보다 성능이 좋음
 	@set계열 : 순서을 유지하지 않고 저장, 중복저장안됨
 		-저장 순서가 유지되지 않고, 중복 객체도 저장하지 못하게 하는 자료구조,null도 1개의 null만 가능
 		