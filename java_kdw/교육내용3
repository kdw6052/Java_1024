 자바정리================================
 @변수 
 	-데이터를 저장하기 위한 공간
 	-값이 바뀔 수 있다
 	-변수 선언 방법
 		타입 변수명 = 초기값;
 	-기본타입(기본 자료형)
 	-정수 : byte, short, int, long//long형 리터럴 상수에는 접미사L
 	-문자 : char
 	-논리 : boolean
 	-실수 : float ,double
 		-소수점 자리 차이 : 정확도
 		-표현범위 차이
 		-float형 리터럴 상수에는 접미사f
 	-자료형 변환
 		-변수/상수의 자료형을 일시적으로 변환
 		-자동
 			-정수 => 실수
 			-작은바이트=>큰 바이트
 		-강제(명시적)
 			-자동으로 안되는 경우
 			-상황에 따라서 자동으로 되는 상황이지만 필요에 의해 강제로 하는 경우도 있음
 			=>연산할 떄
 	-변수명 작성 규칙
 		-숫자가 첫글자가 될 수 없음
 		-특수문자는 _또는 $만 가능
 		-변수명 중복 선언 불가
 			-필드와 지역변수는 중복될 수 있다.
 			=>필드는 this.필드명으로 지역변수와 구분하여 접근할 수 있기 때문에
 			-같은 범위에서 동일한 이름을 가진 지역변수를 선언할 수 없음
 		-대소문자 구별
 	-변수명 작성 관례
 		-카멜표기법 
 			-변수명을 소문자로 작성하고, 여러단어로 된 변수명인 경우 
 			 두번째 단어부터 첫 글자만 대문자로
 			-클래스/인터페이스/열거형명을 소문자로 작성하고, 첫번째 단어부터 첫 글자만 대문자로
 		-변수명은 의미있게
 			-구글 번역, 네이버 사전을 통해
 @상수
 -리터럴 상수
 	-1,'1',"1", true
	-리터럴 상수를 저장하는 공간이 따로 있어서 리터럴 상수가 언급되면 사용 
	-문자열인 경우 같은 리터럴 문자열을 저장하는 문자열 객체들은 같은 주소를 공유
	 String str1 = "hi";
	 String str2 = "hi"; //str1과 str2는 같은 주소를 저장
 -상수 변수
 	-변수 앞에 final 키워드가 붙어서 상수로 만듬
 	-값이 바뀔 수 없다
 	-지역 변수인 상수는 선언과 동시에 초기화를 반드시 해야함.
 	-필드인 상수는 생성자에서 초기화 할 수 있음
 -변수 종류
 	-지역 변수 : 메소드 안에서 선언 된 변수, 메소드를 빠져 나가면 사라짐
 	-필드 : 클래스의 멤버 변수
 	-매개 변수 : 메소드를 실행할 때 필요한 변수들, 메소드를 빠져 나가면 사라짐
 	-참조 변수 : 객체, 열거형 등을 저장하는 변수, 기본 자료형이 아닌 변수들
 	-클래스 필드 : static이 붙은 필드들, 동일한 클래스의 객체들이 공유하는 변수
 	-인스턴스(객체)필드 : static이 안붙은 필드들, 객체마다 필드가 존재
 -매개변수와 인자
 	-매개변수는 메소드 선언부에 있는 변수
 	-인자는 메소드를 호출하기 위해 넘겨준 값(변수/상수)
 @연산자
 -대입 : =, 오른쪽 값을 왼쪽에 저장 => ==와 혼동하지 말자
 -산술 : +-*/%
 	-정수 연산자 정수 => 정수
 		-특히 나누기 조심 1/2는 0.5가 아닌 0
 	-/와%는 두번째 피연산자가 0이면 안됨 =>AtithmeticException 발생
 -비교 : 크기 비교
 	-<=를 =<로, >=를 =>로 잘못 쓰지말자
 	-참/거짓 => 조건식
 -논리 : && || !
 	-&& : ~이고,하고, 둘다 참이면 참
 	-|| : ~이거나, 둘다 거짓이면 거짓
 	-! : 반대
 	-조건식
 -증감연산자 : ++, --
 	-전위 : 증가하고 동작
 	-후위 : 동작하고 증가
 -조건선택 연산자 : 꼭 알필요는 없지만 잘 사용하면 코드가 깔끔해진다
 	=>조건식으로 대체 가능
 	-조건식 ? 참일때 : 거짓일때;
 @조건식
 -조건/상황에 따라 결과가 달라질 때 조건식을 사용
 -~이면...한다  => ~: 조건식 , ...: 실행문
 -if문
 	-if(조건식){실행문;}
 	else if(조건식2){실행문2;}
 	else{실행문3;}
 -switch문
 	-if문에서 특정 상황이면 switch를 쓰는게 코드가 깔끔하다
 	-변수에 저장된 값에 따라 다르게 실행되는 경우/ 특정 연산 결과가 제한적인 경우
 	-값에는 문자, 정수, 문자열만 가능
 	-break는 생략이 가능
 	-default는 0개 또는 1개
 @반복문
 -반복적인 작업을 규칙적으로 할 때 적용
 	=>반복횟수, 규칙성 => 반복횟수 = 초기화+조건식+증감식, 규칙성=실행문
 	-for(int i=0 ; i<=10 ; i+2){
 	 		sysout(i)} = 0,2,4,6,8,10
 	-while(조건식){실행문;//증감식;}
 	-do{실행문}while(조건식);
 	-for(변수 : 배열 또는 컬렉션){}
 @배열
 -같은 타입의 변수들을 모아 놓은것 + (같은 의미)
 -배열은 참조 변수. 주소를 저장
 =>할당된 배열이 있는 0번지의 주소를 저장
 -배열 선언 방법
 	타입 [] 배열명1, 배열명2; //둘다 배열 
 	타입 배열명3[], 배열명4;  //3만배열, 4는 변수
 -배열 할당
 	배열명 =  new 타입[크기];
 -배열은 번지를 통해 접근 가능
 -배열은 0번지부터 크기-1번지까지
 -배열 이용시 ArrayIndexOutOfBoundsException 조심
 -배열의 크기는 length를 이용하여 알 수 있다.
 -배열은 할당하면 각 번지에 있는 값들이 기본값으로 초기화가 됨
 	-정수 : 0, 실수 : 0.0, 참조변수 : null, 문자:'\u0000'
 -배열사용 이유 : 반복문을 이용하여 효율적으로 코딩할 수 있다.
 @메소드
 -하나의 기능을 모아놓은 코드
 -입력정보 : 매개변수, 출력정보 : 리턴타입
 -매개변수 : 메소드를 실행하기 위해 꼭 필요한 정보
 @접근제한자
 -private : 나
 -default : 나 + 같은패키지
 -protected : 나 + 같은패키지 + 자식 클래스들
 -public : 전부
 @메소드 오버로딩
 -동일한 메소드가 여러개 있는 것
 -메소드명 동일
 -매개변수는 갯수가 다르거나 타입이 달라야함
 @클래스
 -필드 + 메소드 + 생성자
 -필드 : 클래스를 나타내는 정보들
 	-학생 클래스는 이름, 학년, 반, 번호등의 정보들을 가지고 있다.
 -생성자 : 필드를 초기화 하는곳
 	-리턴타입이 없음.void아님
 	-생성자 이름은 클래스명과 동일
 -메소드 : 클래스에서 실행하는 기능들
 	-리모컨 클래스는 전원과 켜기/끄기 기능이 있다
 #클래스
 -캡슐화, 상속, 다형성
 -캡슐화
 	-클래스의 메소드가 어떻게 구현됐는지 알 필요가 없다
 -상속
 	-자식에게 필드/메소드를 물려줌 =>코드의 재사용
 -다형성
 	-부모 클래스의 객체로 다양한 자식 클래스의 객체를 관리할 수 있는 것
 	-객체의 다형성, 매개변수의 다형성
 -객체 생성
 	-클래스명 객체명 = new 생성자();
 -객체에서 메소드 호출
 	-객체명.메소드명(매개변수들);
 -메소드 호출
 	-클래스 메소드(static) : 클래스를 통해 호출
 		-클래스명.메소드명(매개변수들);
 	-인스턴스 메소드
 		-클래스명 객체명 = new 생성자();
 		객체명.메소드명(매개변수들);
 -상속
 	-부모 클래스의 필드/메소드를 물려 받는 것
 	-접근제한자에 따라 접근하지 못하는 필드/메소드가 있을 수 있음
 	-extends
 		-class 자식클래스명 extends 부모클래스명{}
 	-자식 클래스는 부모 클래스가 1개
 	=> 클래스 상속은 단일 상속
 	-메소드 오버라이딩
 		-부모 클래스에 있는 메소드를 재정의 하는 것
 		-메소드명이 동일, 매개변수 갯수와 타입이 동일
 		-리턴타입도 동일
 		-접근제한자는 부모 클래스의 메소드보다 같거나 넓어야 함
 		=>부모 클래스의 메소드가 public이면 자식이 오버라이딩할 때 private로 할 수 없음
 		-예외 던지기도 조상 예외로 하는건 괜찮지만 좁아지면 안됨
 		=>부모 클래스의 메소드가 RuntimeException이 발생하는데 
 		  자식이 오버라이딩할 때 ArithmeticException으로 좁힐 수 없음
 @this와 super
 -this는 클래스 자신을 참조하는 변수
 -super는 부모 클래스의 객체를 참조하는 변수
 -this()는 클래스 자신의 다른 생성자를 호출
 -super()는 부모 클래스의 생성자를 호출
 @메소드와 this
 -클래스의 메소드에서 this를 사용하는 경우
 	-항상 사용이 가능
 	-주로 매개변수명과 필드명이 같은 경우 구분을 위해 this를 사용
 @클래스의 형변환
 -자동 : 자식클래스의 객체를 부모클래스의 참조변수가 관리
 	-부모클래스 객체A = new 자식클래스생성자();
 		-객체A는 자식클래스에만 있는 메소드는 그냥 사용 불가
 		-객체A는 부모클래스에 있는 메소드는 다 사용 가능
 		=>((자식클래스명)객체A).메소드()
 -강제 : 부모 클래스의 객체를 자식클래스의 참조변수가 관리하는 경우인데, 
 		조건부로 아래와 같은 경우만 가능
 	-부모클래스 객체B = new 자식클래스생성자();
 	-자식클래스 객체C = (자식클래스)객체B;
 @기본API
 -래퍼클래스
 	-기본 자료형을 클래스로 만듬
 		-byte =>Byte, short =>Short, int => Integer, long =>Long
 		-char =>Charater
 		-float => Float, double => Double
 		-제네릭 클래스는 <>안에 클래스명이 필요함
 			=>기본 자료형을 사용할 수 없음
 			=>기본 자료형을 대체할 수 있는 래퍼 클래스 이용
 		-박싱 : 기본자료형 => 래퍼클래스의 객체로
 		-언박싱 : 래퍼클래스의 객체 => 기본자료형으로
 		-래퍼클래스 객체 사용시 null체크
 -String
 	-문자열 클래스
 	-String 객체에 값을 수정하면 문자열이 교체
 	-leghth() : 문자열의 길이
 	-substring(int start , ind end) : start번지부터 end-1번지까지 부분 문자열을 리턴
 	-charAt(int index) : index 번지에 있는 문자열을 가져옴
 	-split(구분자) : 구분자를 기준으로 문자열들을 추출하여 문자열 배열을 리턴
 		"A,B,C".split(",")=>0번지 : A, 1번지 :B, 2번지 : C
	-indexOf("문자열") : 문자열이 있으면 시작번지를, 없으면 -1을 리턴
	-toUpperCase() : 문자열을 대문자로
	-toLowerCase() : 문자열을 소문자로 		
 -Date
 	-날짜 정보를 관리하는 클래스
 	-Date =>문자열로
 	=>SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
 		String dateStr = format.format(date);
 	-문자열 => Date로
 	=>Date date = format.parse(str);
 -Math
 	-min(int num1, int num2) : num1과 num2중 작은수를 리턴
 	-max(int num1, int num2) : num1과 num2중 큰수를 리턴
 	-abs(int num) : 절대값
 	-round(double num) : 반올림(소수점 첫번째 자리)
 	-floor(double num) : 버림(소수점 첫번째 자리)
 	-ceil(double num) : 올림(소수점 첫번째 자리)
 	-pow(a,b) : a의 b제곱
 	-sqrt(a) : 루트 a
 -StringTokenizer : 구분자를 기분으로 문자열들을 가져와서 확인해주는 클래스
 	-String 클래스의 split과 유사
 	-counTokeㅜs() : 현재 토큰의 개수
 	-hasMoreTokens() : 토큰이 더 있는지 참/거짓으로 알려줌
 	-nextToken() : 다음 토큰
 -Object
 	-모든 클래스의 최상위 조상클래스 
 		=> 모든 클래스는 Object클래스에 있는 메소드를 가지고 있다
 		=> 오버라이드를 통해 재정의 할 수 있다.
 	-equals() : 
 		-Object클래스의 equals는 주소가 같은 객체인 경우만 true
 		-객체의 필드들이 같더라도 같은 주소의 객체가 아니면 false
 		-오버라이딩을 이용하여 필드가 같으면 같은 객체로 판별하도록 작성
 	-toString() :
 		-패키지명과 클래스명과 @주소가 나옴
 		-객체를 통해 간단히 필드들을 확인할 때 오버라이딩하여 사용
 @추상메소드
 -메소드 구현부가 없는 메소드
 -오버라이딩이 필요한 메소드
 @추상클래스
 -추상메소드가 0개 이상 있는 메소드
 -키워드로 abstract가 필요
 -추상메소드에는 반드시 abstract를 추가해야함
 -추상 클래스를 상속받은 자식클래스를 생성한 후, 추상메소드들을 
  오버라이딩하고 객체를 생성
 @인터페이스
 -추상메소드와 클래스상수필드(final static)로 구성
 -메소드에 abstract를 생략해도 자동으로 추가 됨 + public
 -구현 클래스를 생성한 후, 추상 메소드들을 오버라이딩하고 객체를 생성
 @예외처리
 -직접처리
 	-try~catch
 		try{ 예외가 발생할 수 있는 코드}catch(예외 클래스1 e){예외처리;}catch(예외 클래스2 e){예외처리;}
 	-예외 클래스2가 예외클래스1의 조상클래스이거나 자식이 아닌 예외클래스
 	-예외 클래스2에 예외클래스1의 자손클래스가 오면 에러가 발생
 -예외 던지기
 	-throw
 	=>조건문과 같이 사용
 	=>throw new 예외클래스명(예외메세지);
 	-throws
 	=>throw를 이용하는 경우 메소드에 예외가 발생할 수 있다는 것을 표시할 때 사용
 	=>매개변수 옆에 표시
 	=>RuntimeException 이거나 자손클래스이면 생략 가능, 아니면 생략 불가능
 -예외 클래스 종류
 	-ArithmeticException : 0으로 나눌때 발생
 	-ArrayIndexOutOdBoundException : 배열의 범위를 벗어날 때 발생
 	-NegativeArraySizeException : 배열의 크기를 음수로 했을 때 발생
 	-NullPointerException : null인 객체의 필드나 메소드에 접근하려고 했을 때
 	-ClassCastException : 클래스 변환에 실패했을때
 	-FileNotFoundException : 파일을 찾을 수 없을 때
 @컬렉션 프레임워크
 -데이터를 효율적으로 관리하기 위한것
 -컬렉션
 	-공통
 		-add(E e) : 요소 추가 true/false 리턴
 		-remove(E e) : 요소 제거하고 true/false 리턴
 		-size() : 크기
 		-isEmpty() : 비었으면 true 아니면 false
 		-iterator를 이용하여 하나씩 반복하여 요소를 꺼낼 수 있다
 	-리스트
 		-get(int index) : index번지 요소 리턴
 		-ser(int index, E e) : index버지 요소를 e로 수정
 		-remove(int index) : index 번지 요소를 제거하고 성공하면 제거한 객체 리턴
 	-셋
 	-리스트와 셋은 향상된 for문을 이용하여 접근할 수 있다
 -맵
 	-key와 value로 이루어짐
 	-key는 중복 불가
 	-value는 중복 가능
 	-put(K key, V value) : key와 value를 map에 추가
 	-get(K key) : key와 일치하는 value를 반환
 	-set(K key, V value) : key와 일치하는 객체에 value로 수정
 	-keySet() : key값들을 set으로 반환
 	-entrySet() : key와 value값들을 key와 value로 구성된 Entry 클래스 객체들을 
 				  set에 저장하여 반환
 	-반복문 활용(전체 탐색)
 		-1.keySet()을 이용하여 key값들을 이용하여 get으로 가져옴. Itetator
 		-2.entrySet()을 이용하여 Entry클래스 객체를 가져오고 Entry클래스 객체의 
 			key와 value 값을 활용. Iterator
 @입출력
 -서버 
 	-서버소켓 생성
 	-bind를 통해 포트와 IP주소를 연결
 	-accept()를 통해 요청이 올때까지 대기
 	-클라이언트 요청하여 수락
 -클라이언트
 	-소켓생성
 	-connect를 통해 IP주소와 포트를 연결하여 연결요청
 -공통
 	-파일을 열었으면 close()로 닫아야함
 	-InputStream, OutputStream을 통해 연결하여 데이터를 주고 받으면됨
 	-이때, 쓰레드를 이용
 -InputStream : 읽기모드, 파일이 없으면 예외발생
 -OutputStream : 쓰기모드, 파일이 없으면 새로생성
 	-있으면 덮어쓰기
 	-있으면 이어쓰기 : 파일을 열때 파일명 옆에 , true를 추가
 @네트워크